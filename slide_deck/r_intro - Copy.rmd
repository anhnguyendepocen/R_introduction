---
author: Hans Henrik Sievertsen (h.h.sievertsen@bristol.ac.uk)
title: "Introduction to R"
subtitle: "University of Bristol"
date: "Version: January 24 - 2020"
output:
  beamer_presentation:
  keep_tex: no
theme: metropolis
latex_engine: xelatex
slide_level: 2
incremental: no
fontsize: 8pt
classoption: compress
header-includes:
  \setbeamercolor{frametitle}{bg=gray}
  \hypersetup{colorlinks,citecolor=orange,filecolor=red,linkcolor=brown,urlcolor=blue}
  \colorlet{shadecolor}{gray!50}
---

```{r,setup, include=FALSE}
knitr::opts_chunk$set(cache=TRUE)
library(tidyverse)
```
```{r set-options, echo=FALSE, cache=FALSE}
options(width = 600)
```



# Introduction

## Plan

1. Introduction 
2. Tidyverse
3. Matrix algebra
4. Functions and optimizers
5. Simulation


## Getting started 

1. Download this **slide deck** and the **example datasets** from [github.com/hhsievertsen/rintro](https://github.com/hhsievertsen/rintro)

2. Download  **R** from [stats.bris.ac.uk/R/](https://www.stats.bris.ac.uk/R/) and install it.

3. Download **RStudio** [https://rstudio.com/](https://rstudio.com/products/rstudio/download/#download) and install it.
                                                 
4. Open R Studio

## Organisation of RStudio

\begin{itemize}
\item [A.] Console 
\item [B.] Script editor
\item [C.] Overview of objects
\item [D.] Documentation/plots/file browser/packages
\end{itemize}

```{r rguide2, echo=FALSE, out.width ='50%',fig.show='hold',fig.align='center'}
knitr::include_graphics(c("graphics/rstudio.png"))
```

## R basics I

**R as a calculator** 

- We can use R as a calculator. Try typing the following in console and press enter:

```{r }
5+3
```

- You can also type 5+3 in the script editor, highlight what you just wrote and click `Ctrl`+`Enter`.
- Using the script editor, the keyboard combination `Ctrl`+`Enter` executes the current line or the selected area.

## R basics II

**The assignment operator:** `<-`

```{r }
value1<-5
```
- The number five is assigned to an object named "value1".
- We can also achieve this using `=` instead of `<-` , but I recommend getting used to using `<-` as it will become of advantage later on.

- We can also use named objects in the calculator approach:

```{r }
value1<-5
value1+3
```
## R basics III

**Printing**

- We can ask to display the content of an object using `print()`

```{r }
value1<-5
value2<-3
value3<-value1+value2
print(value3)
```
- `R` returns the value of an expression automatically, this is called automatic printing.
```{r }
value1<-5
value2<-3
value3<-value1+value2
value3 
```
- Automatic printing is disabled in loops, functions etc (more on that later).


## R basics IV

**R functions**

- `print()` is an example of a R function.
- The name of this function is `print`
- The function options (called arguments) go inside the `()`. 
- This is general R syntax: 
- If you include `()` after a name, R knows it is a function. If you don't include `()` R knows it is not a function.

- Functions can accept many arguments inside the `()`.

- **Ordered**  arguments
```{r eval=FALSE}
print(value3,TRUE)
```
  
- **Named**  arguments
```{r eval=FALSE}
print(x=value3,quote=TRUE)
```

## R basics V

**Object types**


```{r }
var<-TRUE
typeof(var)
```

```{r }
var<-4L
typeof(var)
```


```{r }
var<-4141.2
typeof(var)
```


```{r }
var<-"Hello1"
typeof(var)
```

- Additional types: NULL,raw, complex, list, expression

## R basics VI

**Vectors**

- We **combine** several objects in a vector using the `c()` function.

```{r }
value1<-5
value2<-3
value3<-value1+value2
vector1<-c(value1,value2,value3)
print(vector1)
```

- a list is **homogeneous**: all objects are **coerced** to be of the same type.
```{r }
object1<-414.041
object2<-"hello!"
vector2<-c(object1,object2)
print(vector2)
```
(all objects are strings)

## R basics VII

**Comments**

\begin{itemize}
\item We should annotate our R script with comments about what we are doing.
\item \emph{Problem:} R will try to execute or comments as R code. 
\item \emph{Solution:} Content after the \# symbol is ignored by R.
\item []
\end{itemize}

```{r eval=FALSE}
# This is line is ignored by R
this is not ignored by R # but this is
```



## R basics VIII

**Working directory**
\begin{itemize}
\item We specify the working directory with `setwd()`.
\item [] (the default location for saving and loading files.)
\end{itemize}
```{r }
setwd("C:\\Users\\hs17922\\Documents")
```
- Note: use `\\` instead of `\`.

**R documention**
- Most functions in R are well documented. 
- We can access the documentation by typing `?nameoffunction`. For example:
```{r,eval=FALSE }
?setwd
```

# Tidyverse

## Installing and loading packages

\begin{itemize}
\item R is powerful.
\item R with extra packages is very powerful.
\item \textbf{tidyverse} is a collection of packages (ggplot2, tidyr,readr, dplyr and more) that are useful for working with data.
\item to \textbf{install a package} (examplified by "tidyverse").
\item [] (We need to do this only once on every system.)
\end{itemize}
```{r ,eval=FALSE}
install.packages("tidyverse")
```
\begin{itemize}
\item to \textbf{load a packages} (examplified with "tidyverse").
\item [] (We have to do that once for every R session.)
\end{itemize}
```{r ,message=FALSE}
library("tidyverse")
```
## Loading data into R

**Data formats**

- Datasets come in many formats depending on how they were created and saved (Excel, Stata, etc).
- R can load many types of datasets (but sometimes we have to load a special package to load a specific format).
-  `read_csv()` from the `readr` package (included in tidyverse) is convenient for loading datasets ending on ".csv". 
- Note that  `read.csv()` is a slightly different function. 

## Loading data into R

**Loading data with read_csv()**
```{r,eval=FALSE}
mydataset<-read_csv("example_data1.csv")
```
\tiny
```{r,echo=FALSE}
mydataset<-read_csv("example_data1.csv")
```
\normalsize

- The dataset named "example_data1.csv" in the current working directory is now loaded in R under the name `mydataset`.
- The dataset is loaded with 15 columns.
- The first variable is a character (i.e. text) type variable and all outhers are double precision floating point numbers. 

## Viewing data

What is in `mydataset`?

- `print()` will (attempt to) display the full dataset in the console. Not feasible for large datasets.
- `head()` displays the first six observations in the dataset.
``` {r ,eval=FALSE}
head(mydataset)
```
\tiny
```{r,echo=FALSE,width=999}
head(mydataset)
```
\normalsize
- `tail()` displays the last six observations in the dataset.
- `View()` opens the dataset in a viewer. 

## Tidying data I

**Tidy data**

- The **tidy data principles**  state that each *variable* must have its own *column* and each *observation* must have its own row. 
- The example dataset is not tidy. 
  - The variables `test_year_5` to `test_year_9` violate the tidy data principles.
  - The variables contain information about test scores. 
  - The values 5, 6, 7, 9, and 9 are information about the year of the test score, this should be stored in rows for a variable called year.

- The function `pivot_longer()` (from the *tidyr* package) can be used to gather several columns in one column (makes the dataset longer). 
- The function `pivot_wider()` (from the *tidyr* package) can be used to spread one columns to several columns (makes the dataset wider). 

## Tidying data II

**pivot_longer()**

- `pivot_longer(data, cols, names_to, values_to=)`
- `data`: the name of the dataset. 
- `cols`: the columns to convert. 
- `names_to`: the new variable where the information that is currently in the column headers (for example the test year) should be stored.
- `values_to`: the variable where the values from the old rows are to be stored.

```{r,eval=FALSE}
tidydata<-pivot_longer(mydataset,cols=7:15,
                       names_to="year",values_to="test_score")
options(dplyr.width = Inf)
head(tidydata)
```

\tiny
```{r,echo=FALSE}
tidydata<-pivot_longer(mydataset,cols=7:15,names_to="year",values_to="test_score",)
options(dplyr.width = Inf)
head(tidydata)
```

(I used `options(dplyr.width = Inf)` to specify the number of columns to print.)
\normalsize

## Tidying data III

**pivot_wider()**

- `pivot_wider(data, names_from, values_from=)`
- `data`: the name of the dataset. 
- `names_from`: the new columns get their names from this variable. 
- `values_from`: the new columns get their values from this variable. 

```{r,eval=FALSE}
dirtydata<-pivot_wider(tidydata,
                       names_from="year",values_from="test_score")
options(dplyr.width = Inf)
head(dirtydata)
```

\tiny
```{r,echo=FALSE}
dirtydata<-pivot_wider(tidydata,
                       names_from="year",values_from="test_score")
options(dplyr.width = Inf)
head(dirtydata)
```

(I used `options(dplyr.width = Inf)` to specify the number of columns to print.)
\normalsize

## Data processing I

**filter**

- `filter(data, criteria)`
- We filter specific rows (observations) of a dataset using the `filter()` function (from the dplyr package).
- `data`: the name of the dataset. 
- `...`: the filtering criteria.

```{r,eval=FALSE}
filtered_data<-filter(tidydata,year=="test_year_2")
options(dplyr.width = Inf)
head(filtered_data)
```

\tiny
```{r,echo=FALSE}
filtered_data<-filter(tidydata,year=="test_year_2")
options(dplyr.width = Inf)
head(filtered_data)
```

(I used `options(dplyr.width = Inf)` to specify the number of columns to print.)
\normalsize

## Data processing II

**select**

- `select(data, ...)`
- We select specific columns (variables) of a dataset using the `select()` function (from the dplyr package).
- `data`: the name of the dataset. 
- `...`: the name (or number) of the columns to keep. To remove a variable, add a "-" in front of the variable.

```{r,eval=FALSE}
selected_data<-select(filtered_data,
                      c(person_id,summercamp,test_score))
options(dplyr.width = Inf)
head(selected_data)
```

\tiny
```{r,echo=FALSE, messages=FALSE}
selected_data<-select(filtered_data,
                      c(person_id,summercamp,test_score))
options(dplyr.width = Inf)
head(selected_data)
```

(I used `options(dplyr.width = Inf)` to specify the number of columns to print.)
\normalsize

## Data processing III

**rename**

- `rename(data, newname1=oldname1,newname=oldname,...)`
- We rename columns using the rename function
- `data`: the name of the dataset. 
- `newname1`: the new name of the first column to rename. 
- `oldname1`: the old name of the first column to rename.
- `newname2`: the new name of the second column to rename.
- ...
```{r,eval=FALSE}
renamed_data<-rename(selected_data,
                      score=test_score,camp=summercamp)
options(dplyr.width = Inf)
head(renamed_data)
```

\tiny
```{r,echo=FALSE, messages=FALSE}
renamed_data<-rename(selected_data,
                      score=test_score,camp=summercamp)
options(dplyr.width = Inf)
head(renamed_data)
```

(I used `options(dplyr.width = Inf)` to specify the number of columns to print.)
\normalsize

## Data processing IV

**mutate**

- `mutate(data, nameofnewvariable=expression, ...)`
- We create and modify columns using the mutate function
- `data`: the name of the dataset. 
- `nameofnewvariable`: the  name of the first column to rename. 
- `expression`: the definition of the new variable
- ...
```{r,eval=FALSE}
mutated_data<-mutate(renamed_data,
                      camptest=score*camp,constant=1)
options(dplyr.width = Inf)
head(mutated_data)
```

\tiny
```{r,echo=FALSE, messages=FALSE}
mutated_data<-mutate(renamed_data,
                      camptest=score*camp,constant=1)
options(dplyr.width = Inf)
head(mutated_data)
```

(I used `options(dplyr.width = Inf)` to specify the number of columns to print.)
\normalsize

## Data processing V

**merge**

- `merge(x,y,by="matchingvar")`
- We merge two datasets using the `merge()` function.
- `x`: the name of the first dataset.
- `y`: the name of the second dataset.
- `matchingvar`:  rows with the same value of `matchingvar` in both `x` and `y` are matched. 
- ...
```{r,eval=FALSE}
myotherdataset<-read_csv("example_data2.csv")
merged_data<-merge(mutated_data,myotherdataset,by="person_id")
options(dplyr.width = Inf)
head(merged_data)
```

\tiny
```{r,include=FALSE}
myotherdataset<-read_csv("example_data2.csv")
```

```{r,echo=FALSE, messages=FALSE}
merged_data<-merge(mutated_data,myotherdataset,by="person_id")
options(dplyr.width = Inf)
head(merged_data)
```

(I used `options(dplyr.width = Inf)` to specify the number of columns to print. Some output is hidden.)

\normalsize


## Data processing VI

**The pipe: %>%**

- Throw the left-hand side value forward into the right-hand side expression.
- So $f(x)$ can be written as as $x$`%>%`$f()$.
- **Example**

```{r,eval=FALSE}
renamed_data<-rename(mydataset,score=test_score)
mutated_data<-mutate(renamed_data,camptest=score*camp)
filtered_data<-filter(mutated_data,female==1)
selected_data<-select(filtered_data,person_id,camptest)
```

can be written as:

```{r,eval=FALSE}
selected_data<-mydataset%>%
               rename(score=test_score)%>%
               mutate(camptest=score*camp)%>%
               filter(female==1)%>%
               select(person_id,camptest)
```

\small

- For more details see chapter 18 in "R for data science: import, tidy, transform, visualize, and model data." (Wickham & Grolemund, 2016)  [r4ds.had.co.nz](https://r4ds.had.co.nz)

\normalsize


## Data processing VII

**group_by** & **summarise**

- `group_by(data,...)`
  - `data`: the name of the dataset. 
  - `...`: the  names of the columns to group the dataset by.

- `summarise(data,varname=expression)`
  - summarises the dataset on the `group_by` (if defined) level.
  - `data`: the name of the dataset. 
  - `varname`: the name of the new variable.
  - `expression`: the definition of the new variable.

```{r,eval=FALSE}
summarised_data<-mydataset%>%
                 group_by(summercamp)%>%
                 summarise(average_score=mean(test_year_2))
print(summarised_data)
```

\tiny
```{r,echo=FALSE, messages=FALSE}
summarised_data<-mydataset%>%
                 group_by(summercamp)%>%
                 summarise(average_score=mean(test_year_2))
print(summarised_data)
```

\normalsize

For more details see  ["section 5.6 in R for data science: import, tidy, transform, visualize, and model data." (Wickham & Grolemund, 2016)](https://r4ds.had.co.nz/transform.html#grouped-summaries-with-summarise).


## Base graphics I

**base** refers to base R (without any functionality from loaded packages).

`plot(x,y,..)`

-`x` the variable to plot on the x-axis.

-`y` the variable to plot on the y-axis.

-`...` settings ()

  - ` type = "l"`: line chart type (try also  "o", "p", "l", & "b").
  - `lty = "dotted"`: dotted line type (try also "dashed").
  - `col = "blue"`: blue line.
  - `lwd=2`: line width.
- `lines()` or `points()` to add more lines

For more details see  [R Base Graphics: An Idiot's Guide](https://rstudio-pubs-static.s3.amazonaws.com/7953_4e3efd5b9415444ca065b1167862c349.html).



## Base graphics II


```{r,eval=FALSE, }
var1<-c(15, 17, 17, 20, 25)
var2<-c(55, 67, 62, 60, 70)
var3<-c(75, 67, 60, 62, 80)
plot(var1,var2,
     type="l",lty="dashed",col="green",lwd=2)
lines(var1,var3,
      type="l",lty="solid",col="blue",lwd=2)
```



```{r,echo=FALSE,fig.width=7,fig.height=6, fig.align = "center", out.width = '150pt'}
var1<-c(15, 17, 17, 20, 25)
var2<-c(55, 67, 62, 60, 70)
var3<-c(75, 67, 60, 62, 80)
plot(var1,var2,
     type="l",lty="dashed",col="green",lwd=2)
lines(var1,var3,
      type="l",lty="solid",col="blue",lwd=2)
```




## ggplot I


**ggplot2** a grammar for graphics

- `ggplot(data,aes(x,y,...))`
- `data`: the name of the dataset. 
- `...`: `aes()` the aesthetic mappings
-`x` the variable to plot on the x-axis.
-`y` the variable to plot on the y-axis.

- `+geom_line()`
- `+` add a layer to the ggplot object
- `geom_line()` add a line chart using the data and the aesthetic mappings specified in ggplot() (`geom_line` inherits the settings specified in `ggplot()`).

- `+geom_point(data,aes(x,y,...))`
- `+` add a layer to the ggplot object
- `geom_point()` add a scatter plot using the data and the aesthetic mappings specified specifeid within `geom_point()`.

- `+theme()`: specify theme settings (colors, position etc.)
- `+labs()`: specify axes titles, chart title, caption, legend titles, etc..


For more details see  ["chapter 3 in R for data science: import, tidy, transform, visualize, and model data." (Wickham & Grolemund, 2016)](https://r4ds.had.co.nz/data-visualisation.html#first-steps). 
                                                                                                                                           
                                                                                                                                           
## ggplot II


**ggplot2** a grammar for graphics


```{r,eval=FALSE, }
ggplot(mydataset,aes(x=parental_lincome,y=test_year_2))+
 geom_line()
```

```{r,echo=FALSE,fig.width=7,fig.height=6, fig.align = "center", out.width = '150pt'}
ggplot(mydataset,aes(x=parental_lincome,y=test_year_2))+geom_point()
```



## Tidyverse summary

- Tidyverse package tools for working with data: load, tidy, process, visualize data.

- See "R for data science: import, tidy, transform, visualize, and model data." (Wickham & Grolemund, 2016) for more details. 
- available here: [r4ds.had.co.nz](https://r4ds.had.co.nz).

- Download tidyverse_exercises.R from [github.com/hhsievertsen/rintro](https://github.com/hhsievertsen/rintro) to practice on your own.
       

# Matrix algebra

## A vector
- We would like to enter the following vector $A$ into R

$$A= \left[\begin{matrix}3\\5\\4\end{matrix}\right]$$

- We already know how to do this. We simply use `c()`:

```{r}
A=c(3,5,4)
A
```
- Note that R prints it as row, but it is a column vector. 



## A vector transposed

- To verify that $A$ is really a column vector, let's consider the transpose of A:

$$A^T= \left[\begin{matrix}3,5,4\end{matrix}\right]$$
- which we can achieve using `t()` in R:

```{r}
t(A)
```

- Where the `m` in `[m,n]` refers to the **row** and the `n` to the **column**.

- and let's consider the transpose of the transposed matrix to get back to the original $A$ vector.:
```{r}
t(t(A))
```

## The matrix function

- We can also explictly create vectors and matrices using the `matrix()` function. 
- To create our A vector, we write:
```{r}
A=matrix(c(3,5,4),ncol=1)
A
```
- Note the difference between
```{r}
A=matrix(c(3,5,4),ncol=1)
class(A)
```
and
```{r}
A=c(3,5,4)
class(A)
```

## Entering a matrix with the matrix function 

**Creating a 2x2 matrix**

- Let us now consider a 2 by 2 matrix $B$:

$$B= \left[\begin{matrix}3,5\\11,2\end{matrix}\right]$$
- which we can enter as:
```{r}
B=matrix(c(3,11,5,2),ncol=2)
B
```
- R first fills the first column, then the second etc...
- and the transpose of B:
```{r}
t(B)
```

## Addition

**Adding a number to a matrix**

- Let $\alpha$ be a number (a scalar), then $\alpha + B$ is:
$$\alpha B= \left[\begin{matrix}\alpha +  3,\alpha + 5\\\alpha +  11,\alpha +  2\end{matrix}\right]$$


- and in R:
```{r}
B=matrix(c(3,11,5,2),ncol=2)
alpha=0.5
alpha+B
```

## Addition

**Adding two matrices together**

- Consider the following two matrices

$$ C= \left[\begin{matrix} 1,2 \\ 3, 4 \end{matrix}\right] \text{ and  }
   D= \left[\begin{matrix} 5,6 \\ 7, 8 \end{matrix}\right] $$
  
- The sum of these two matrices is then given by::

$$C + D=\left[\begin{matrix} 1 + 5,2 + 6 \\ 3 + 7, 4 + 8 \end{matrix}\right]$$
- and in R:
```{r}
C=matrix(c(1,3,2,4),ncol=2)
D=matrix(c(5,7,6,8),ncol=2)
C+D
```


## Addition


**Warning: pay attention to dimensions of matrices**

- Note: the dimensions have to align when adding two matrices together:

```{r, error=TRUE}
E=matrix(c(1,3,2,4),ncol=1)
F=matrix(c(5,7,6,8),ncol=2)
E+F
```

- $E$ is a $1\times 4$ matrix.
- $F$ is a $2\times 2$ matrix.

  -We want to add the element in the first row and first column of $E$ to the element in the first row and the first column of $F$ That's okay.
  - ...
  - We want to add the element in the third row and first column of $E$ to the element in the third row and the first column of $F$. That's not doable, because  $F$ only has two rows.
  
  
## Multiplication

**Multiplying a matrix with a number**


- Let $\alpha$ be a number (a scalar), then $\alpha B$ is:

$$\alpha B= \left[\begin{matrix}\alpha \times  3,\alpha \times 5\\\alpha\times  11,\alpha \times  2\end{matrix}\right]$$

- and in R:
```{r}
B=matrix(c(3,11,5,2),ncol=2)
alpha=0.5
alpha*B
```


## Multiplication

**Element-wise multiplication**


- Consider the following two matrices

$$ C= \left[\begin{matrix} 1,2 \\ 3, 4 \end{matrix}\right] \text{ and  }
   D= \left[\begin{matrix} 5,6 \\ 7, 8 \end{matrix}\right] $$
   
- The Hadamard product (or element-wise multiplication) of matrices $C$ and $D$ is then given by:

$$E=C\circ D=\left[\begin{matrix} 1\times 5,2 \times 6 \\ 3 \times 7, 4 \times 8 \end{matrix}\right]$$

- and in R:

```{r}
C=matrix(c(1,3,2,4),ncol=2)
D=matrix(c(5,7,6,8),ncol=2)
C*D
```


## Multiplication

**Warning: pay attention to dimensions of matrices**

- Note: element-wise multiplication of two matrices also requries that dimensions (i.e. number of rows and columns) match :

```{r, error=TRUE}
E=matrix(c(1,3,2,4),ncol=1)
F=matrix(c(5,7,6,8),ncol=2)
E*F
```

- $E$ is a $1\times 4$ matrix.
- $F$ is a $2\times 2$ matrix.

  -We want to multiply the element in the first row and first column of $E$ with the element in the first row and the first column of $F$ That's okay.
  - ...
  - We want to multiply the element in the third row and first column of $E$ with the element in the third row and the first column of $F$. That's not doable, because  $F$ only has two rows.
  
  
  
## Multiplication

**Matrix multiplication **


- Consider again the following two matrices

$$ C= \left[\begin{matrix} 1,2 \\ 3, 4 \end{matrix}\right] \text{ and  }
   D= \left[\begin{matrix} 5,6 \\ 7, 8 \end{matrix}\right] $$
   
- Let's now consider  the  product of matrices $E$ and $D$:

$$C  D=\left[\begin{matrix} 
1\times 5+2\times 7,
1\times 6+2\times 8\\
3\times 5+4\times 7,
3\times 6+4\times 8
\end{matrix}\right]$$

- and in R:

```{r}
C=matrix(c(1,3,2,4),ncol=2)
D=matrix(c(5,7,6,8),ncol=2)
C%*%D
```

## Multiplication

**Warning: pay attention to dimensions of matrices**

- Note: matrix multiplication of two matrices  requries that the number of rows in the left hand side matrix correspond to the number of columns in the right hand side matrix.

```{r, error=TRUE}
E=matrix(c(1,3,2,4),ncol=1)
F=matrix(c(5,7,6,8),ncol=2)
E%*%F
```

- $E$ is a $1\times 4$ matrix.
- $F$ is a $2\times 2$ matrix.

  -We want to multiply the elements of the first row in matrix $E$ to the elements of the first column of matrix $F$, but the former has one element and the latter has two elements!
  
## Some special matrices 

- A 0-matrix (all entries are zero):

```{r, error=TRUE}
matrix(0, nrow = 2, ncol = 2)
```

- A $J$ matrix (all entries are 1s):
```{r, error=TRUE}
matrix(1, nrow = 2, ncol = 2)
```

- A matrix where all  entries outside the  diagonal are  zero:
```{r, error=TRUE}
diag(c(1,2,3))
```

## Some special matrices 

- The identity matrix, $I$, is a diagonal matrix, where all elements in the diagonal are 1. 

```{r, error=TRUE}
diag(c(1,1))
```

- An Identity matrix satisfies $IA=AI=A$, where A is a matrix. 
```{r, error=TRUE}
A=matrix(c(1,3,4,5),ncol=2)
I=diag(c(1,1))
A%*%I
```

We can also appy `diag()` on matrix to extract the diaognal

```{r, error=TRUE}
A=matrix(c(1,3,4,5),ncol=2)
diag(A)
```


- A $J$ matrix (all entries are 1s):
```{r, error=TRUE}
matrix(1, nrow = 2, ncol = 2)
```

- A matrix where all  entries outside the  diagonal are  zero:
```{r, error=TRUE}
diag(c(1,2,3))
```

## The inverse of a matrix

- Let $A$ be a $n \times n$ matrix (a square matrix, because the number of rows equals the number of columns).
- Let $B$ be $n \times n$ matrix which multiplied by matrix $A$ gives the identity matrix:

$$ AB=BA=I$$

- The matrix B is called A's inverse, $B=A^{-1}$.
- Finding the inverse matrix is numerically complicated. But luckily we can ask R to do it for us by means of the `solve()` function:

```{r, error=TRUE}
A=matrix(c(1,3,4,5),ncol=2)
solve(A)
```

- let's test it:

```{r, error=TRUE}
solve(A)%*%A
```

## The determinant of a matrix

- A matrix is not invertible if the determinant is zero (the matrix is then called singular).
- The determinant of matrix $A$ is written as $det(A)$ or $|A|$.
- For a 2x2 matrix, the determinant is defined as

$$det(A)=|A|= \begin{vmatrix} a,b\\c,d\end{vmatrix}  =a\times d-b\times c.$$
- So for the A matrix defined earlier it is given by:


$$det(A)= \begin{vmatrix} 1,3\\4,5\end{vmatrix}  =1\times 5-3\times 4=-7.$$

```{r, error=TRUE}
A=matrix(c(1,3,4,5),ncol=2)
det(A)
```

## Combining matrices

**Column bind:** `cbind(A,B,..)`

- combines matrices $A$, $B$, .. horizontally (binds the columns).

```{r, error=TRUE}
A=matrix(c(1,3,4,5),ncol=2)
B=matrix(c(1,3,4,5),ncol=2)
cbind(A,B)
```

**Row bind:** `rbind()`

- combines matrices $A$, $B$, .. vertically (binds the columns).

```{r, error=TRUE}
rbind(A,B)
```

## Application: ordinary least squares

- Let's return to our data and estimate the following model using ordinary least squares: 

\vspace{-12pt}

$$test\_year\_6_i=\beta_0+\beta_1 parental\_lincome+\beta_2 summercamp_i+e_i$$

- We can achive this with `lm()` function in R:

```{r,eval=FALSE}
mydataset<-read_csv("example_data1.csv")
my_lm<-lm(test_year_6~parental_lincome+summercamp,data=mydataset)
summary(my_lm)
```

\normalsize
- In `lm()` we first specify the model to estimate: `y~x1+x2+..` (R automatically adds a constant).
- We store the result of fitting the model using OLS in the object called `my_lm`
- We use the `summary()` function to summarize the results.


## Application: ordinary least squares

- Let's check the output


```{r,eval=FALSE}
mydataset<-read_csv("example_data1.csv")
my_lm<-lm(test_year_6~parental_lincome+summercamp,data=mydataset)
summary(my_lm)
```
\tiny
```{r,include=FALSE}
mydataset<-read_csv("example_data1.csv")
```
```{r,echo=FALSE}
my_lm<-lm(test_year_6~parental_lincome+summercamp,data=mydataset)
summary(my_lm)
```


## Application: Ordinary Least Squares

*Manual OLS using R* 

- Let's try to manually reproduce these results from lm() using the matrix tools we just covered.
- We know that the OLS estimates in matrix form are given by:

$$\hat{\beta}=(X^TX)^{-1}X^Ty$$

- We know how to find the inverse, how to multiply matrices and how to transpose matrices in R. We are ready!

**But**
- We need to get the data from the dataset into the matrix format first!


```{r,eval=FALSE}
mydataset<-read_csv("example_data1.csv")
class(mydataset)
```
\tiny
```{r,include=FALSE}
mydataset<-read_csv("example_data1.csv")
```
```{r,echo=FALSE}
class(mydataset)
```

\normalsize

- `mydataset` is a `tibble` (or a data frame), not a matrix. 
- A matrix is homogeneous (just like vectors created with `c()`).
- Data frames allow for a mix of types (integer, double, character).

## Application: Ordinary Least Squares

**From data frame to matrix: method 1**

- We can access a specific column of a dataframe using the `$` symbol:

```{r,eval=FALSE}
mydataset<-read_csv("example_data1.csv")
mydataset$test_year_6
```
\tiny
```{r,include=FALSE}
mydataset<-read_csv("example_data1.csv")
```
```{r,echo=FALSE}
mydataset$test_year_6
```

- let's save data  in a column vector called y:

```{r,eval=FALSE}
mydataset<-read_csv("example_data1.csv")
y=matrix(mydataset$test_year_6,ncol=1)
```

## Application: Ordinary Least Squares

**From data frame to matrix: method 2**

- We can convert a data frame to a matrix using the `as.matrix()` function:

```{r,eval=FALSE}
X<-read_csv("example_data1.csv")%>%
            select(parental_lincome,summercamp)%>%
            mutate(constant=1)%>%
            as.matrix()
class(X)
```
\tiny
```{r,include=FALSE}
x<-read_csv("example_data1.csv")
```
```{r,echo=FALSE}
X<-x%>%select(parental_lincome,summercamp)%>%
            mutate(constant=1)%>%
            as.matrix()
class(X)
```

\normalsize

## Application: Ordinary Least Squares

**Let's find the OLS estimates**

- We now simply plugin the OLS formula in R

$$\hat{\beta}=(X^TX)^{-1}X^Ty$$

\small
```{r,eval=FALSE}
# load dataset
mydataset<-read_csv("example_data1.csv")
# extract the dependent variable and store as column vector y
y=matrix(mydataset$test_year_6,ncol=1)
# extract the covariates to include and create a constant and as matrix X
X<-mydataset%>%
   select(parental_lincome,summercamp)%>%
   mutate(constant=1)%>%
   as.matrix()
# implement OLS formula
betahat=solve(t(X)%*%X)%*%t(X)%*%y
# show betahat vector
betahat
```
\tiny
```{r,include=FALSE}
# load dataset
mydataset<-read_csv("example_data1.csv")
# extract the dependent variable and store as column vector y
y=matrix(mydataset$test_year_6,ncol=1)
# extract the covariates to include and create a constant and as matrix X
X<-mydataset%>%
   select(parental_lincome,summercamp)%>%
   mutate(constant=1)%>%
   as.matrix()
# implement OLS formula
betahat=solve(t(X)%*%X)%*%t(X)%*%y

```
```{r,echo=FALSE}
# show beta vector
betahat
```

\normalsize
- Estimated coefficients are identical to the results obtained with `lm()`!

## Application: Ordinary Least Squares

**Fitted values**

- the fitted values are given by $X\hat{\beta}$.
- the residuals are given by $y-X\hat{\beta}$.
- we can create a q-q plot of the betas using base graphics:

\small
```{r,eval=FALSE}
#calculate residuals
residuals<-(y-X%*% betahat)
# create histogram
qqnorm(residuals)
```
\tiny
```{r,include=FALSE}
# load dataset
mydataset<-read_csv("example_data1.csv")
# extract the dependent variable and store as column vector y
y=matrix(mydataset$test_year_6,ncol=1)
# extract the covariates to include and create a constant and as matrix X
X<-mydataset%>%
   select(parental_lincome,summercamp)%>%
   mutate(constant=1)%>%
   as.matrix()
# implement OLS formula
betahat=solve(t(X)%*%X)%*%t(X)%*%y

```
```{r,echo=FALSE,fig.width=7,fig.height=6, fig.align = "center", out.width = '150pt'}
# show beta vector
residuals<-(y-X%*% betahat)
# create histogram
qqnorm(residuals)
```


## Matrix algebra - summary

- Create column vector A: `A=c()`.
- Create matrix A: `A=matrix()`.
- Convert B to matrix A: `A=as.matrix(B)`.
- Transpose matrix A: `t(A)`.
- Inverse of matrix A: `solve()`.
- Element-wise multiplication of matrix `A` and `B`: `A*B`.
- Matrix multiplication of matrix `A` and `B`: `A%*%B`.
- Extract the column named `col1` from data frame `df`: `df$col1`.
- OLS estimator: `betahat=solve(t(X)%*%X)%*%t(X)%*%y`.


       
                                                                                                                                           


# Functions

## Defining functions

**What is a function**?

- a set of R statements that perform a task given a set of provided arguments. 

- Example:  `lm(test_year_6~parental_lincome+summercamp,data=mydataset)`

  - The function `lm()` estimates coefficients of a linear model.
  - The model is provided as the first argument (`test_year_6~parental_lincome+summercamp`)
  - The dataset is provided as a second (named) argument ( `mydataset`).

**User defined functions**

- We can easily create our own functions in R.
- The syntax is as follows:

```{r, eval=FALSE}
function_name <- function(arg_1, arg_2, ...) {
   Function body 
}
```
The function consists of four parts:

1. The function name.
2. The arguments (placeholders for settings, datasets etc). 
3. The function  body (a collection of statements to carry out using the arguments provided).
4. Return value (the last expression of the function)


## Our first function

**Let's define a function**

1. name: Hansfunction
2. arguments: `x` and `y`
3. function body:  `z=x*y`
4. return: return(z)

- Let's define that function
```{r}
Hansfunction <- function(x, y) {
   z=x*y
   z
}

```
- Let's try the function
```{r}
Hansfunction(3,6)
```

- What if we forget to state an argument?
```{r,error=TRUE}
Hansfunction(3)
```


## Default values

**Let's define a function with default values**

- To avoid such cases, we can specify **default** values:
- When defining the function, we set the arguments equal to their default values.
- Let's define that function
```{r}
Hansfunction <- function(x=2, y=2) {
   z=x*y
   z
}
Hansfunction(3)
```

- This works well, but if you accidentially forgot an argument!


## Control structures

**Control structures**

- We can use **control structures** to control the statements executed by our function.
- Here is an example of a control structure in plain English:

```{r, eval=FALSE,error=TRUE}
if logical test evaluates to true do the following
    statements to execute if TRUE
else do the following
    statements to execute if not TRUE
```

- and in terms of R syntax:

```{R,eval=FALSE,error=FALSE}
if (logical test){
  
  }
  else{
  
}
```

- A logical test is a statement that evaluates to TRUE or FALSE, for example:  
  - "5 is greater than 3" The statement is TRUE
  - "3 is greater than 5" The statement is FALSE

- Control statements can also be used outside functions (in scripts, loops etc).

## Control structures

**Control structures in Hansfunction()**

```{r}
Hansfunction <- function(x=2, y=3) {
  if (missing(x)|missing(y)){
     print("Warning: Not all arguments provided. Default values used.")
  }
  else{
     print("Well done, you specified all arguments!")
  }
     z=x*y
     z
}
Hansfunction(3)
```
- here we use the function `missing()` to test whether the argument missing.
- the `|` corresponds to "or" (the logical expression evaluates to true if x OR y are missing).
- We can use the symbol "&" if we only want the expression to evaluate to true if both are x and y are missing. 

## Our own lm() function

**Let's build our own lm() function**

- We now use the tools from the matrix section and combine them with the function definitions to create our own lm function.

\small
```{r,eval=FALSE}
mylm <- function(y,x,data) {
  # specify dataset
  df<-data
  # extract the dependent variable and the covariates
  yvar<-df%>%select(y)%>%as.matrix()
  Xvar<-df%>%select(x)%>%mutate(constant=1)%>%as.matrix()
  # implement OLS formula and return betahat vector
  solve(t(Xvar)%*%Xvar)%*%t(Xvar)%*%yvar
}
# load data
mydataset<-read_csv("example_data1.csv")
# try our new function
mylm(x=c("parental_lincome","summercamp"),y="test_year_4",data=mydataset)

```
\tiny
```{r,include=FALSE}
mylm <- function(y,x,data) {
  # specify dataset
  df<-data
  # extract the dependent variable and the covariates
  yvar<-df%>%select(y)%>%as.matrix()
  Xvar<-df%>%select(x)%>%mutate(constant=1)%>%as.matrix()
  # implement OLS formula and return betahat vector
  solve(t(Xvar)%*%Xvar)%*%t(Xvar)%*%yvar
}
mydataset<-read_csv("example_data1.csv")

```
```{r,echo=FALSE}
mylm(x=c("parental_lincome","summercamp"),y="test_year_4",data=mydataset)

```
                                                                        
## Loops

**For loop**

- a for loop repeats a list of statements
- the number of times the statements are repeated is stated in the loop *header*
- the statements are provided in the *body*
- example:

\small
```{r,eval=FALSE}
for (x in 1:3){
  print(x)
}
```
\tiny
```{r,echo=FALSE}
for (x in 1:3){
  print(x)
}
```
\normalsize
- the loop header `for (x in 1:3){` states that the loop should be repeated 3 times:
  1. Once where `x` has the value 1
  2. Once where `x` has the value 2
  3. Once where `x` has the value 3.
  
- the loop header  states that in each loop *iteration* the statment `print(x)` should be executed. 

## Loops

**While loop**

- we can also create a loop that repats itself until a certain condition is violated.
- this is called a **while** loop.
- the loop body statements are repeated until the while condition is violated. 
- example:

\small
```{r,eval=FALSE}
x=1
while (x<5){
  print(x)
  x=x+1
}
```
\tiny
```{r,echo=FALSE}
x=1
while (x<5){
  print(x)
  x=x+1
}
```
\normalsize
- the object `x` is initiated with a value of 1.
- the loop is repeated until `x<5` evaluates to false.
- in every iteration we:
  - print the value of x.
  - add the value of 1 to x.

## Application: maximum likelihood

**Maximum likelihood**: find the parameters that maximize the likelihood that we observe, given a distribution.

- application: estimate the probability that a child probability participates in the summer school using a probit model.

- **benchmark**: R's built-in function

\small
```{r ,eval=FALSE}
mydataset<-read_csv("example_data1.csv")
# Estimate the probit model
probit<-glm(summercamp~parental_lincome,
            family = binomial(link = "probit"), data = mydataset)
# Show parameter estimates
summary(probit)
```
\tiny
```{r, include=FALSE}
# Probit estimation using glm
mydataset<-read_csv("example_data1.csv")
```

```{r ,echo=FALSE}
# Estimate the probit model
probit<-glm(summercamp~parental_lincome,
            family = binomial(link = "probit"), data = mydataset)
# Show parameter estimates
summary(probit)
```



## Application: maximum likelihood

- The likelihood for a single observation:

$$L(\beta;y_i,x_i)=[\Phi(x'_i\beta)]^{y_i}[1-\Phi(x'_i\beta)]^{1-y_i}$$

- Observations are assumed to be $iid$, we can therefore write the likelihood of the entire sample as the product of the individual likelihoods:

$$L(\beta;y,X)=\prod_{i=1}^N [\Phi(x'_t\beta)]^{y_i}[1-\Phi(x'_t\beta)]^{1-y_i}$$

- The **log**-likelihood is then given by:

$$l(\beta;y,X)=\sum_t\left(y_t\ln\Phi(x'_t\beta) + (1-y_t)\ln\left(1-\Phi(x'_t\beta)\right)\right)$$

- **R implementation**
  - $\Phi()$  is the cumulative distribution function of the standard normal distribution, which we implement in R with `pnorm()`.
  - `sum()` computs the sum
  - We can therefore implement the above in R as:
`l<-sum(y*log(pnorm(xb))+(1-y)*log(1-pnorm(xb)))`  
  

## Application: maximum likelihood

- The log-likelihood for $\beta=[-11.9,0.79]$ (the values R found for us).
\small
```{r, eval=FALSE}
# load data
df<-read_csv("example_data1.csv")
# y variable
y<-df%>%select(summercamp)%>%as.matrix()
# x variable 
X<-df%>%select(parental_lincome)%>%mutate(constant=1)%>%as.matrix()
# xb (note constant is given last)
xb<-X%*%c(0.79,-11.9)
# log likelihood
l<-sum(y*log(pnorm(xb))+(1-y)*log(1-pnorm(xb)))
# return value
l
```
\tiny
```{r, include=FALSE}
# load data
df<-read_csv("example_data1.csv")
```
```{r, echo=FALSE}
# y variable
y<-df%>%select(summercamp)%>%as.matrix()
# x variable 
X<-df%>%select(parental_lincome)%>%mutate(constant=1)%>%as.matrix()
# xb (note constant is given last)
xb<-X%*%c(0.79,-11.9)
# log likelihood
l<-sum(y*log(pnorm(xb))+(1-y)*log(1-pnorm(xb)))
# return value
l
```

- Okay, but how do we know this is maximized? Let's evaluate the log likelihood value for various values of beta. To do this we:
  1. Wrap the likelihood in a function
  2. Loop over the function and use different values
  
## Application: maximum likelihood

**1. Our likelihood function**
\small
```{r,eval=FALSE}
my_loglikelihood <- function(y,x,beta,data) {
  # specify dataset
  df<-data
  # extract the dependent variable and the covariates
  yvar<-df%>%select(y)%>%as.matrix()
  Xvar<-df%>%select(x)%>%mutate(constant=1)%>%as.matrix()
  # beta
  betavec=beta
  # xb (note constant is given last)
  xb<-Xvar%*%betavec
  # log likelihood
  l<-sum(yvar*log(pnorm(xb))+(1-yvar)*log(1-pnorm(xb)))
  # return
  l
}
# load data
mydataset<-read_csv("example_data1.csv")
# try our new function
my_loglikelihood(x="parental_lincome",y="summercamp",
                 beta=c(0.79,-11.9) ,data=mydataset)
```
\tiny
```{r,include=FALSE}
# load data
mydataset<-read_csv("example_data1.csv")


```
```{r,echo=FALSE}
my_loglikelihood <- function(beta,y,x,data) {
  # specify dataset
  df<-data
  # extract the dependent variable and the covariates
  yvar<-df%>%select(y)%>%as.matrix()
  Xvar<-df%>%select(x)%>%mutate(constant=1)%>%as.matrix()
  # beta
  betavec=beta
  # xb (note constant is given last)
  xb<-Xvar%*%betavec
  # log likelihood
  l<-sum(yvar*log(pnorm(xb))+(1-yvar)*log(1-pnorm(xb)))
  # return
  l
}
# load data
# try our new function
my_loglikelihood(x="parental_lincome",y="summercamp",
                 beta=c(0.79,-11.9),data=mydataset)

```
## Application: maximum likelihood

**2. Loop over values**

- Simplification: keep beta 0 constant at -11.9 and vary beta1
```{R}
# loop over values of beta1
for (i in 0:1){
  print(my_loglikelihood(x="parental_lincome",y="summercamp",
                 beta=c(i,-11.9),data=mydataset))
}

```

- Okay, that works, but 2 values are a bit boring. Let's try more!

## Application: maximum likelihood

- Let's loop over more values, store all results in a data frame and show the likelihood in a chart as a function of beta 1:
\small 
```{R,fig.width=7,fig.height=4, fig.align = "center", out.width = '150pt'}
# create empty matrix to store values
df<-data.frame(beta1=seq(0,1.1,by=0.01),loglikelihood=NA)
# loop over values of beta1
for (i in 1:nrow(df)){
  beta1<-df[i,1]
  df[i,2]<-my_loglikelihood(x="parental_lincome",y="summercamp",
                 beta=c(beta1,-11.9),data=mydataset)
}
# let's plot the log likelihood as a function of beta 1
ggplot(df,aes(x=beta1,y=loglikelihood))+geom_line()
```

## Application: maximum likelihood

- The chart indicates that the maximum value of the log-likelihood function could be around 0.79 (as the R built-in function suggest).
- But how do we find the exact values? And how about $\beta_0$?
- We use a built-in optimizer. An function to maximize or minimize to mimize an expression.
- One such function is `optim()`:

\small

```{r ,eval=FALSE}
# use the R function optim to optimize ll
optim(c(0,0), my_loglikelihood, control=list(fnscale = -1),x="parental_lincome",y="summercamp",data=mydataset)
```

\tiny

```{r ,echo=FALSE}
# use the R function optim to optimize ll
optim(c(0,0), my_loglikelihood, control=list(fnscale = -1),
      x="parental_lincome",y="summercamp",data=mydataset)
```

## Functions, control structures, loops - summary

\small
- We **define functions** using the following syntax:
```{r ,eval=FALSE}
function_name <- function(arg_1, arg_2, ...) {
   function body 
}
```

- We  control the flow of our function using control structure:

```{r ,eval=FALSE}
if (logical test){
  action to do if logical test evaluates to true
}
else {
  action to do if logical test evaluates to false
}
```

- We repeat statements using loops

```{r ,eval=FALSE}
for (x in range){
  action to repeat for all values in range
}
```

- We can combine these tools and implement a maximum likelihood estimator

